package testlight

import (
	"encoding/csv"
	"fmt"
	"io"
	"sort"
	"strings"
	"time"

	"github.com/timshannon/bolthold"
	"github.com/vanti-dev/bsp-ew/pkg/gen"
)

// ReportEntry is a summary of emergency lighting data for a single emergency light.
type ReportEntry struct {
	Name                   string                    // Smart Core device name of the emergency light
	LastUpdate             time.Time                 // The most recent time we check for new data from this light
	Faults                 []gen.EmergencyLightFault // List of faults most recently reported
	LatestFunctionTestPass time.Time                 // Takes the zero value if no function test pass recorded.
	LatestDurationTestPass time.Time                 // Takes the zero value if no duration test pass recorded.
}

// GenerateReport creates a summary of emergency lighting data for all lights that are present in the database's
// LatestStatusRecord collection.
// Results are ordered by Name.
func GenerateReport(db *bolthold.Store) ([]ReportEntry, error) {
	data := make(map[string]*ReportEntry)

	// get the latest status for all lights we know about
	err := db.ForEach(nil, func(record *LatestStatusRecord) error {
		data[record.Name] = &ReportEntry{
			Name:       record.Name,
			LastUpdate: record.LastUpdate,
			Faults:     record.Faults,
		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	// find the latest function and duration test for each light
	query := bolthold.Where("Kind").In(FunctionTestPassEvent, DurationTestPassEvent)
	aggregates, err := db.FindAggregate(&EventRecord{}, query, "Name", "Kind")
	if err != nil {
		return nil, err
	}
	for _, aggregate := range aggregates {
		var (
			name   string
			kind   EventKind
			latest EventRecord
		)
		aggregate.Group(&name, &kind)
		aggregate.Max("Timestamp", &latest)

		entry, ok := data[name]
		if !ok {
			// we don't know about this device
			continue
		}

		switch kind {
		case FunctionTestPassEvent:
			entry.LatestFunctionTestPass = latest.Timestamp
		case DurationTestPassEvent:
			entry.LatestDurationTestPass = latest.Timestamp
		default:
			// other values were excluded by the query, this can't happen unless there is a bug
			panic(fmt.Sprintf("unexpected EventRecord.Kind %v", kind))
		}
	}

	// convert into a slice sorted by name
	result := make([]ReportEntry, 0, len(data))
	for _, entry := range data {
		result = append(result, *entry)
	}
	sort.Slice(result, func(i, j int) bool {
		return result[i].Name < result[j].Name
	})
	return result, nil
}

// WriteReportCSV will write a report as generated by GenerateReport as a CSV file.
// Fields writen, in order, are:
//   - Name
//   - Last Update (date+time in RFC3339 format)
//   - Faults (space-seperated list of enum names)
//   - Latest Function Test Pass (date, in "yyyy-mm-dd" format, or empty if no test recorded)
//   - Latest Duration Test Pass (as above)
//
// If header=true, then column names will be written as the first row.
func WriteReportCSV(dst io.Writer, report []ReportEntry, header bool) (err error) {
	writer := csv.NewWriter(dst)
	if header {
		err = writer.Write([]string{"Name", "Last Update", "Faults", "Latest Function Test Pass", "Latest Duration Test Pass"})
		if err != nil {
			return err
		}
	}

	for _, entry := range report {
		var faultStrings []string
		for _, fault := range entry.Faults {
			faultStrings = append(faultStrings, fault.String())
		}

		var latestFunctionString, latestDurationString string
		if !entry.LatestFunctionTestPass.IsZero() {
			latestFunctionString = entry.LatestFunctionTestPass.Format("2006-01-02")
		}
		if !entry.LatestDurationTestPass.IsZero() {
			latestDurationString = entry.LatestDurationTestPass.Format("2006-01-02")
		}

		line := []string{
			entry.Name,
			entry.LastUpdate.Format(time.RFC3339),
			strings.Join(faultStrings, " "),
			latestFunctionString,
			latestDurationString,
		}

		err = writer.Write(line)
		if err != nil {
			return err
		}
	}
	writer.Flush()
	return writer.Error()
}
