package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v4"
	"github.com/vanti-dev/bsp-ew/pkg/gen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// CreateTenant registers a new tenant in the database. The tenant has an autogenerated ID.
func CreateTenant(ctx context.Context, tx pgx.Tx, title string) (*gen.Tenant, error) {
	// language=postgresql
	query := `
		INSERT INTO tenant (id, title, create_time) VALUES (DEFAULT, $1, $2) RETURNING id;
	`

	tenant := &gen.Tenant{
		Title:      title,
		CreateTime: timestamppb.Now(),
	}
	row := tx.QueryRow(ctx, query, tenant.Title, tenant.CreateTime.AsTime())
	err := row.Scan(&tenant.Id)
	if err != nil {
		return nil, err
	}
	return tenant, nil
}

func GetTenant(ctx context.Context, tx pgx.Tx, id string) (*gen.Tenant, error) {
	// language=postgresql
	query := `
		SELECT title, create_time FROM tenant WHERE id = $1;
    `

	tenant := &gen.Tenant{Id: id}
	row := tx.QueryRow(ctx, query, id)
	var createTime time.Time
	err := row.Scan(&tenant.Title, &createTime)
	tenant.CreateTime = timestamppb.New(createTime)
	if err != nil {
		return nil, err
	}

	// obtain list of assigned zones
	// language=postgresql
	query = `
		SELECT zone_name FROM tenant_zone WHERE tenant = $1;
    `
	rows, err := tx.Query(ctx, query, id)
	if err != nil {
		return nil, err
	}
	for rows.Next() {
		var zone string
		err = rows.Scan(&zone)
		if err != nil {
			return nil, err
		}
		tenant.ZoneNames = append(tenant.ZoneNames, zone)
	}
	return tenant, nil
}

// AddTenantZones will store an association between the given tenant and a set of zones.
// Will fail if the tenant doesn't exist.
func AddTenantZones(ctx context.Context, tx pgx.Tx, tenantID string, zones []string) error {
	cols := []string{"tenant", "zone"}
	var rows [][]any
	for _, zoneID := range zones {
		rows = append(rows, []any{tenantID, zoneID})
	}
	_, err := tx.CopyFrom(ctx, pgx.Identifier{"tenant_zone"}, cols, pgx.CopyFromRows(rows))
	return err
}

func RemoveTenantZones(ctx context.Context, tx pgx.Tx, tenantID string, zones []string) error {
	// language=postgresql
	query := `
		DELETE FROM tenant_zone
		WHERE tenant = $1 AND zone_name = $2;
	`

	batch := &pgx.Batch{}
	for _, zone := range zones {
		batch.Queue(query, tenantID, zone)
	}

	br := tx.SendBatch(ctx, batch)
	defer func() {
		_ = br.Close()
	}()
	for i := 0; i < batch.Len(); i++ {
		_, err := br.Exec()
		if err != nil {
			return err
		}
	}
	return br.Close()
}

// CreateTenantSecret adds a tenant secret to the database.
// Only the fields TenantID, Name, SecretHash and Expires will be used from secret.
// Returns the newly created tenant secret row.
func CreateTenantSecret(ctx context.Context, tx pgx.Tx, secret *gen.Secret) (*gen.Secret, error) {
	secret = proto.Clone(secret).(*gen.Secret)

	// language=postgresql
	query := `
		INSERT INTO tenant_secret (id, tenant, secret_hash, note, expiration) VALUES (DEFAULT, $1, $2, $3, $4)
		RETURNING id;
    `

	row := tx.QueryRow(ctx, query, secret.Tenant.GetId(), secret.SecretHash, secret.Note, secret.ExpirationTime.AsTime())
	err := row.Scan(&secret.Id)
	if err != nil {
		return nil, nil
	}
	return secret, nil
}

func DeleteTenantSecret(ctx context.Context, tx pgx.Tx, secretID string) error {
	// language=postgresql
	query := `
		DELETE FROM tenant_secret
		WHERE id = $1;
    `

	tag, err := tx.Exec(ctx, query, secretID)
	if err != nil {
		return err
	}
	if tag.RowsAffected() == 0 {
		return pgx.ErrNoRows
	}
	return nil
}
